---
layout:     post
title:      数仓建模：拉链表的概念详解及使用示例
subtitle:   
date:       2022-01-01
author:     dex0423
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - 数仓建模
---


# 1. 什么是拉链表

##### 1.1. 拉链表定义

- 所谓拉链，顾名思义，就是记录历史，记录一个事物从开始，一直到当前状态的所有变化的信息。
- 拉链表，是针对数据仓库设计中表存储数据的方式而定义的。拉链表的核心思想，像个拉链，支持开链，支持闭链，支持退链。我们通常将最新的数据称为开链数据，历史数据称为闭链数据。
- 拉链表在一个时间维度中，同一个用户只保存一条用户状态。
- 拉链表通常会增加三个技术字段：开始日期 `start_time`、结束日期 `endtime`、状态标识 `mark`。
- 通过主键（PK）与历史数据进行对比，判断当前数据与历史数据是否发生变化，如果发生变化或者新增则进行相应的开链、闭链操作。
- 拉链表支持历史数据查询，且空间占用较小，但是数据加工处理较为繁琐，属于时间换空间的设计方式。

##### 1.2. 拉链表示例

- 下面是一张拉链表，存储的是用户的最基本信息以及每条记录的生命周期，通过这张表可以获取到最新的当天数据以及之前的历史数据。

- 拉链表示例：

    ![]({{site.baseurl}}/img-post/拉链表-1.png)

    - `t_start_date`，表示该条记录的生命周期开始时间；
    - `t_end_date`，表示该条记录的生命周期结束时间；
    - `t_end_date='9999-12-31'`，表示该条记录目前处于有效状态；
    - 如果查询当前所有有效的记录，则使用 `select * from user where t_end_date = '9999-12-31'` 即可以获取；
    - 如果查询 `2017-01-01` 当天的历史快照，则 `select * from user where t_start_date <= '2017-01-01' and end_date >= '2017-01-01'`。

# 2. 为什么需要拉链表

##### 2.1. 海量数据更新问题

- 在数据仓库的数据模型设计过程中，经常会遇到下面这种表的设计： 
  - 数据量比较大； 
  - 表中的部分字段会被 update，如：
    - 用户联系方式；
    - 客户收件地址；
    - 产品的描述信息；
    - 订单的状态；
    - 等等。
  - 需要查看某一个时间点或者时间段的历史快照信息，比如：
    - 查看某一个订单在历史某一个时间点的状态；
    - 查看某一个用户在过去某一段时间内更新过几次；
    - 等等。
  - 变化的比例和频率不是很大，比如：
    - 总共有 `1000万` 的会员信息记录，每天新增和发生变化的记录有 `10万` 左右；
  
- 对于上面的需求，如果对表每天都保留一份全量数据，那么每次全量中会保存很多不变的信息，这对存储是极大的浪费；
- 针对上面的需求，该如何设计表，有三种方案可以选择：
  - 方案一：每天只留一份最新的数据。
  - 方案二：保留一份全量的切片数据。
  - 方案三：使用拉链表。

##### 2.2. 方案一：每天只留一份最新的数据

- 这种方案实现起来很简单，每天 `drop` 掉前一天的数据，重新抽取一份最新的数据。
- 优点：
  - 很明显，节省空间，一些普通的使用也很方便，不用在选择表的时候加一个时间分区什么的。
- 缺点：
  - 也很明显，没有历史数据，想翻翻旧账只能通过其他方式，比如从流水表里面抽。

##### 2.3. 方案二：每天保留一份全量的切片数据

- 每天一份全量的切片是一种比较稳妥的方案，而且历史数据也在。
- 缺点：
  - 存储空间占用的量太大了，如果对这个表每天都保留一份全量，那么每次全量的数据中会有很多不变的数据，对存储是极大的浪费。
  - 当然我们也可以做一些取舍，比如只保留最近一个月的数据。但是，数据的生命周期就会被严重制约，历史数据大量丢失不符合大数据的建设理念。


##### 2.4. 方案三：使用拉链表

- 拉链表可以看做是对前两种方案的一种折中处理。
- 首先，拉链表在空间上做了一个取舍，虽然不像方案一那样占用量那么小，但是它每日的增量可能只有方案二的千分之一甚至是万分之一，所以空间占用问题也在可接受范围内。
- 其次，它也能满足方案二所能满足的需求，既能获取最新的数据，也能添加筛选条件、以获取历史的数据。


# 3. 拉链表的实现

##### 3.1. 基于 MySQL 实现拉链表

- 数据源
  - ODS 层用户全量表，需要用它来做初始化。
  - 每日的用户更新表，即每日增量表。

- 时间粒度 
  - 确定拉链表的时间粒度，比如说每天拉链表只取一个状态，那即使一天有多次变化，也只取最后一次状态；
  - 这种具体到天粒度的表，其实已经能解决大部分问题了。

- 获取更新变化 
  - 每日的用户更新表，有三种方式拿到每日的用户增量： 
    - 方法一：监听 MYSQL 数据的变化，比如说用 Canal，最后合并每日的变化，获取到最后一个状态；
      - 假设我们每天都会获得一份切片数据，我们可以通过两天切片数据的不同来作为每日更新表的依据；
      - 这种情况下我们对所有的字段先进性 concat、再去MD5，就能实现更新了。
    - 方法二：流水表，有每日变更的流水表
    - 方法三：同步 ODS 用户全量表，对 `modify_time` 为当日时间的数据进行增量同步。

- 查询性能 
  - 随着数据量的增长，链表也会遇到查询性能的问题，比如：
    - 存放了 5年 的用户信息数据，表记录数量势必会比较大，查询的时候性能就比较低；

- 解决思路
  - 在一些查询引擎中，对 start_date 和 end_date 做索引；
  - 设计两张拉链表：
    - 一张表存放全量的拉链表数据；
    - 另一张表对外暴露，只提供近3个月数据的拉链表。

##### 3.2. 基于 Hive 实现拉链表

> **注意**：
> 
> 在现在的大数据场景下，大部分公司都会选择以 HDFS 和 HIVE 为主的数据仓库架构。目前的 HDFS 版本来讲，其文件系统中的文件是不可做改变的，也就是说 HIVE 的表只能进行删除和添加操作，而不能 `update` 操作，基于这个因素我们需要采用 **中间表** 的方式实现。

- 中间表设计
  - TODO
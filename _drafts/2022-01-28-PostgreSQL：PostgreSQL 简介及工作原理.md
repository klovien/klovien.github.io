---
layout:     post
title:      PostgreSQL：PostgreSQL 简介及工作原理
subtitle:   
date:       2022-01-28
author:     dex0423
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - PostgreSQL
---



https://www.bilibili.com/read/cv8138815/


#### 事务的一些重要性质

  事务是所有数据库系统的基础概念。
  
  事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果有某些错误发生导致事务不能完成，则其中任何一个步骤都不会对数据库造成影响。即：
  
  1、一个事务被称为是原子的：从其他事务的角度来看，它要么整个发生要么完全不发生。
  
  2、一个事务型数据库保证一个事务在被报告为完成之前它所做的所有更新都被记录在持久存储（即磁盘）。
  
  事务型数据库的另一个重要性质与原子更新的概念紧密相关：当多个事务并发运行时，每一个都不能看到其他事务未完成的修改。所以事务的全做或全不做并不只体现在它们对数据库的持久影响，也体现在它们发生时的可见性。一个事务所做的更新在它完成之前对于其他事务是不可见的，而之后所有的更新将同时变得可见。
  
#### PostSQL中的事务

  PostgreSQL实际上将每一个SQL语句都作为一个事务来执行。如果我们没有发出BEGIN命令，则每个独立的语句都会被加上一个隐式的BEGIN以及（如果成功）COMMIT来包围它。 一组被BEGIN和COMMIT包围的语句也被称为一个事务块。值得注意的是，某些客户端库会自动发出BEGIN和COMMIT命令，因此我们可能会在不被告知的情况下得到事务块的效果。具体请查看所使用的接口文档。
  
  也可以利用保存点来以更细的粒度来控制一个事务中的语句。保存点允许我们有选择性地放弃事务的一部分而提交剩下的部分。在使用SAVEPOINT定义一个保存点后，我们可以在必 要时利用ROLLBACK TO回滚到该保存点。该事务中位于保存点和回滚点之间的数据库修改都会被放弃，但是早于该保存点的修改则会被保存。
  
  在回滚到保存点之后，它的定义依然存在，因此我们可以多次回滚到它。反过来，如果确定不再需要回滚到特定的保存点，它可以被释放以便系统释放一些资源。记住不管是释放保存点还是回滚到保存点都会释放定义在该保存点之后的所有其他保存点。
  
  所有这些都发生在一个事务块内，因此这些对于其他数据库会话都不可见。当提交整个事务块时，被提交的动作将作为一个单元变得对其他会话可见，而被回滚的动作则永远不会变得可见。
  
  另外，在一个事务块中使用保存点存在很多种控制可能性。以及，使用ROLLBACK TO是唯一重新控制一个由于错误被系统置为中断状态的事务块的途径，而不是完全回滚它并重新启动。 


# 强大的索引类型
  PostgreSQL 支持索引类型
  
  B-tree(默认)：适合顺序检索、范围查询
  Hash：适合简单的等式比较
  GIN：(Generalized Inverted Index)即倒排索引，存储被索引字段的VALUE或VALUE的元素，以及行号的list或tree，适合数组元素查询、全文搜索等。
  rum：GIN的加强，官方开源插件。
  GiST：GiST是一个通用的索引接口，可以使用GiST实现b-tree, r-tree等索引结构。不同的类型，支持的索引检索也各不一样。例如：1）几何类型支持位置距离排序；2）标量类型支持距离排序等等
  SP-GiST：SP-GiST类似GiST，是一个通用的索引接口，但是SP-GIST使用了空间分区的方法，使得SP-GiST可以更好的支持非平衡数据结构，例如quad-trees, k-d tree, radis tree。例如：几何类型支持正交、相交、在上下左右等
  BRIN：BRIN 索引是块级索引，有别于B-TREE等索引，BRIN记录并不是以行号为单位记录索引明细，而是记录每个数据块或者每段连续的数据块的统计信息。因此BRIN索引空间占用特别的小，对数据写入、更新、删除的影响也很小。BRIN属于LOSSLY索引，当被索引列的值与物理存储相关性很强时，BRIN索引的效果非常的好。例如时序数据，在时间或序列字段创建BRIN索引，进行等值、范围查询时效果很棒。
  bloom：基于bloom filter构造的一个索引接口，属于lossy索引，可以收敛结果集(排除绝对不满足条件的结果，剩余的结果里再挑选满足条件的结果)，因此需要二次check，bloom支持任意列组合的等值查询。
  zombodb：PostgreSQL与ElasticSearch结合的一个索引接口，可以直接用sql读写ES。
  其它：PostgreSQL 9种索引的原理和应用场景-阿里云开发者社区 
  可扩展性强：如向量索引(图搜索、人脸识别、个性推荐) 高维向量检索技术在PG中的设计与实践 ——杨文（缁尘）-阿里云开发者社区 
  【PostgreSQL的索引文件和数据文件是完全分开的。都为非聚集索引】



大数据时代，人们使用数据库系统处理的数据量越来越大，请求越来越复杂，对数据库系统的大数据处理能力和混合负载能力提出更高的要求。PostgreSQL 作为世界上最先进的开源数据库，在大数据处理方面做了很多工作，如并行和分区。


# PostgreSQL 的并行查询特性

- 并行查询基础组件，包括:
    - 后台工作进程（Background Work Process）
    - 动态共享内存（Dynamic Shared Memory）
    - 后台工作进程间的通信机制和消息传递机制
    
并行执行算子的实现，包括并行顺序扫描、并行索引扫描等并行扫描算子，三种连接方式的并行执行以及并行 Append
并行查询优化，介绍并行查询引入的两种计划节点，基于规则计算后台工作进程数量以及代价估算

max_parallel_workers_per_gather 参数控制执行节点的最大并行进程数，通过以上并行计划可知，开启并行后，会启动两个 worker 进程（即 Workers Launched: 2）并行执行，且执行时间（Execution Time）仅为不并行的40%。




原理

- PostgreSQL的并行化包含三个重要组件：
    - 进程本身(leader进程)
    - gather
    - workers

- 并行查询计划中，我们将处理用户请求的 backend 进程称之为主进程（leader），将执行时动态生成的进程称之为工作进程（worker）；
- 每个 worker 执行 Gather 节点以下计划的一个副本，leader 节点主要负责处理 Gather 及其以上节点的操作，根据 worker 数不同，leader 也可能会执行 Gather 以下计划的副本；
- 没有开启并行化的时候，进程自身处理所有的数据；一旦计划器决定某个查询或查询中部分可以使用并行的时候，就会在查询的并行化部分添加一个gather节点，将gather节点作为子查询树的根节点；


查询执行是从 leader 进程开始。一旦开启了并行或查询中部分支持并行，就会分配一个gather节点和多个worker线程。relation的blocks在各个workers线程之间划分。workers的数量受postgresql的配置参数控制。workers之间使用共享内存相互协调和通信，一旦worker完成了自己的工作，结果就被传给了leader进程。

workers和leader进程之间使用消息队列(依赖共享内存)进行通信。每个进程有两个队列：一个是error队列；一个是tuples队列。


#

并行查询依赖的两个重要基础组件：后台工作进程和动态共享内存。前者用于动态创建 worker，以并行执行子查询计划；后者用于 leader 和 worker 间通信和数据交互。

# 后台工作进程（Background Worker Process）

PostgreSQL 是多进程架构，主要包括以下几类进程：
  
守护进程，通常称之为 postmaster 进程，接收用户的连接并 fork 一个子进程处理用户的请求
backend 进程，即 postmaster 创建的用于处理用户请求的进程，每个连接对应一个 backend 进程
辅助进程，用于执行 checkpoint，后台刷脏等操作的进程
后台工作进程，用于执行特定任务而动态启动的进程，如上文提到的 worker 进程

上图中 server process 即 postmaster 进程，在内核中，postmaster 与 backend 进程都是 postgres 进程，只是角色不同。对于一个并行查询，其创建 worker 进程的大致流程如下：
client 创建连接，postmaster 为其 fork 一个 backend 进程处理请求
backend 接收用户请求，并生成并行查询计划
执行器向 backgroudworker 注册 worker 进程（并没有启动）
执行器通知（kill）postmaster 启动 worker 进程
worker 进程与 leader 进程协调执行，将结果返回 client


# 动态共享内存（Dynamic Shared Memory）

PostgreSQL 是多进程架构，进程间通信往往通过共享内存和信号量来实现。对于并行查询而言，执行时创建的 worker 进程与 leader 进程同样通过共享内存实现数据交互。但这部分内存无法像普通的共享内存那样在系统启动时预先分配，毕竟直到真正执行时才知道有多少 worker 进程，以及需要分配多少内存。PostgreSQL 实现了动态共享内存，即在执行时动态创建，用于 leader 与 worker 间通信，执行完成后释放。基于动态共享内存的队列用于进程间传递元组和错误消息。

# 并行支持算子

并行执行的算子的实现原理，包括：
  
并行扫描，如并行顺序扫描，并行索引扫描等
并行连接，如并行哈希连接，并行 NestLoop 连接等
并行 Append

# 并行顺序扫描(Parallel sequential scan)

在PostgreSQL 9.6中，增加了对并行顺序扫描的支持。顺序扫描是在表上进行的扫描，在该表中一个接一个的块顺序地被评估。就其本质而言，顺序扫描允许并行化。这样，整个表将在多个workers线程之间顺序扫描。

并行顺序扫描快并不是因为可以并行地读，而是将数据分散到了多个cpu。
顺序扫描产生了大量的行，但是没有使用聚合函数。因此，查询使用的是单个cpu核心。

增加一个sum函数后，很明显使用了两个工作线程，从而使得查询加速：

# 并行聚合(Parallel Aggregation)

在数据库中，计算聚合是非常昂贵的操作。如果以单个进程进行执行，则这将花费相当长的时间。在PostgreSQL 9.6中，通过简单地将它们分成多个块（分而治之策略）来增加了并行计算的能力。多个worker线程执行聚合的部分，然后leader再根据它们的结果计算最终结果。

从技术上讲，将Partial Aggregate节点添加到计划树中，并且每个Partial Aggregate节点包含一个worker线程的输出。然后将这些输出发送到Finalize Aggregate节点，该节点合并来自多个（所有）Partial Aggregate节点的聚合。如此有效的并行部分计划在根部包括一个Finalize Aggregate节点，以及一个将Partial Aggregate节点作为子节点的Gather节点。
